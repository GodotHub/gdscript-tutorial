# 面向对象入门

在前面的章节里，我们写了好多函数和变量，像在做散装工具箱：想干嘛就拼点逻辑，用完就丢

但当我们做的事情越来越复杂，比如一个角色不仅有名字、血量、还会移动攻击回血、甚至还会发怒变身……

这个时候，我们就不能再靠一堆散装函数和变量过日子了，而需要用到一个个对象（Object）

这就是——**面向对象编程（Object-Oriented Programming，简称 OOP）**



# 对象（Object）

现实生活中到处都是对象。

一只猫、一张桌子、一辆车，甚至一张白纸，都是**拥有自己状态与行为**的东西。

每个对象都是一个**独立存在的个体**，它们可以互相影响、互相作用

我们用两个词来描述一个对象：

* **属性（Property）**：对象的状态，比如颜色、大小、血量……

* **行为（Behavior）**：对象能做什么，比如跳跃、行走、奔跑



想象一张白纸它有着极强的可塑性，可被画上任何你所想的画面，也能被折成任何你所想的形状，这就是一个抽象事物逐渐具象化的过程

对象并不是凭空诞生的，它们都是**由类（Class）这个蓝图造出来的**。

你可以把类看作“模板”或“说明书”，

每次用这个模板造出来的，就叫做一个“对象”——也叫“实例（Instance）”。

> 对象 = 类的一个具象化实例，是具有状态和行为的独立个体



# 类（Class）

不能将一个事物描述成一类事物，对象是一个单一独立的个体，类则是具有相同特征和行为个体的统称

比如你有很多猫咪对象，它们颜色不同、性格不同，但都能喵喵叫、吃罐头、蹦来蹦去。这时候我们就可以说：这些猫都是“Cat”这个类的实例。

类就像是一个**模板**，或者**设计图**，它不会自己动，也没有具体的数值或状态，但它规定了对象应该“拥有什么”和“能做什么”。

类提供了：

* 一组 **属性（Property）定义了对象的特征**（比如猫有名字、体重、毛色）

* 一组 **方法（Method）定义了对象的行为**（比如猫可以叫、跑、睡觉）

一旦你用类创建了一个对象，这些属性和方法就会“附着”在那个对象身上，它就成为了一个可以活动的具体个体

**类是对象的蓝图，对象是类的具象存在。**



# 三大基本特征



## 封装（Encapsulation）

封装是面向对象编程的核心思想，它就像给对象套上一个“保护壳”。这个壳子——就是类，它将对象的**属性（数据）** 和 **行为（方法）** 包在了一起。

但不是包在一起就完事了，重点在于：类**隐藏了复杂的实现细节**，对外只提供清晰好用的“使用接口”。

这个概念就是 **“不要告诉我你是怎么做的，只要做就可以了。”**

想象一下你有一个自动贩卖机。你只要按下按钮，饮料就会掉出来～但你完全不需要知道它内部怎么运作、电路怎么连接、如何识别硬币。这就是封装！

同样地，在程序里我们也会：

* **隐藏内部变量和复杂逻辑**（不希望被随意修改）

* **只暴露必要的方法**（让别人能安心使用）

这样一来，不仅让程序更安全，也方便未来维护，不会因为随便改动内部数据就波及整个类



## 继承（Inheritance）

继承就像是对象世界里的“血脉传承”。我们可以通过一个**已有的类**，来创造一个**新的类**，这个新类自动继承了原有类的属性和行为！

这个被继承的类叫做**父类（基类/超类）**

继承它的新类叫做**子类（派生类）**



举个例子，你写了一个 `Animal` 类，它会 `move()` 和 `eat()`。
然后你写了一个 `Cat` 类，你不想重复这些功能，于是让 `Cat` 继承 `Animal`。`Cat` 就自动拥有了`move()` 和 `eat()` 的能力

你还可以在 `Cat` 里加上自己的特有方法，比如 `meow()`，或者重写 `move()`，让猫咪以轻盈的姿态移动

**需要注意的是，可以说子类的实例都是父类的实例，但不能说父类的实例是子类的实例，就好比你可以说猫是一个动物，但不能说动物都是猫**



使用继承可以：

* **复用已有代码**（不需要重复写）

* **扩展和定制功能**（子类可以添加或修改行为）

* **形成“是一个”的关系**（猫 是一个 动物）



## 多态（Polymorphism）

多态是指**相同的行为在不同的对象中可以有不同的表现**。它强调的是 **“统一的接口，多个不同的实现”。**

你可以把它理解为：虽然我们对所有对象都下达的是同一个“指令”，但每个对象会根据自己的特性，做出属于自己的反应

比如你对动物们说“开始工作”，猫咪可能是去巡视阳台，狗狗可能是去看家，小鸟可能开始唱歌——**动作的“名字”是一样的，真正做的事却各有不同**

多态让我们在处理不同对象时，不必去关心它们的具体类型，而是相信它们都会“按规则”完成各自的事情，这让我们的程序更加灵活、简洁、容易扩展

